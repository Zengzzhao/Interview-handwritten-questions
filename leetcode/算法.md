# JS中的指针

在js原生的数据类型中，数组自带一个指针索引，要实现在数据上另外的一个指针从而实现双指针只需设置一个变量给定一个初始值/位置，当数组自带的指针索引移动的时候根据条件对我们自己实现的指针++/--来移动

采用双指针在一个for循环下完成两个for循环的工作

[力扣27题移除元素](https://leetcode.cn/problems/remove-element/description/)的[题解](https://leetcode.cn/problems/remove-element/solutions/10388/hua-jie-suan-fa-27-yi-chu-yuan-su-by-guanpengchn/)的第一种思路，k即为我们自己设置的指针

```js
var removeElement = function(nums, val) {
    let k=0
    for(let num of nums){
        if(num!=val){
            nums[k]=num
            k++
        }
    }
    return k
};
```



# 排序与查找

## 快排

```js
const huafen=(arr,left,right)=>{
    const mid=arr[left]
    while(left<right){
        while(arr[right]>=mid && left<right) right--
        arr[left]=arr[right]
        while(arr[left]<=mid && left<right) left++
        arr[right]=arr[left]
    }
    arr[left]=mid
    return left
}

const Qs=(arr,left,right)=>{
    if(left>=right) return
    const mid=huafen(arr,left,right)
    Qs(arr,left,mid-1)
    Qs(arr,mid+1,right)
}
```



## 二分查找

在一个有序数组中查找是否存在某个元素

对比中间元素与目标元素，若中间元素>目标元素则可能存在的目标元素在左侧，若中间元素<目标元素则可能存在的目标元素在右侧

```js
var search = function (nums, target) {
    let left=0
    let right=nums.length-1
    while(left<=right){
        const mid=Math.floor((right-left)/2)+left
        if(nums[mid]==target) return mid
        if(nums[mid]<target) left=mid+1
        if(nums[mid]>target) right=mid-1
    }
    return -1
};
```



# 滑动窗口

类似双指针，用于求最长的子串（连续的情况）

而动态规划求最长的子串（不要求连续的情况）

[力扣209长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)使用该思想

基本思想：for循环控制窗口末尾位置，自定义一个变量指针指向数组首部视为窗口首位置。滑动窗口的末尾位置当满足要求条件时停止，此时滑动窗口的起始位置，直至不满足条件时停止，再次滑动窗口的末尾位置，重复；一般用于求最值，所以定义一个全局变量result，在滑动的过程中进行比较更新result

```js
var minSubArrayLen = function(target, nums) {
    let sum=0
    let first=0
    let subLength=0
    let result=nums.length+1
    for(let index=0;index<nums.length;index++){
        sum+=nums[index]
        while(sum>=target){
            subLength=index-first+1
            result=result>subLength?subLength:result
            sum-=nums[first++]
        }
    }
    return result==nums.length+1?0:result
};
```



# js通过命令行交互式输入

使用readline模块

```js
const readline = require('readline')
const r1 = readline.createInterface({
    input: process.stdin,
    output: process.stdout
})
let inputLines = []
r1.on('line', (line) => {
    inputLines.push(line)
})
r1.on('close', () => {
	// inputLines中即为命令行输入的数据，对其进行操作即可
})
```



# 链表

js定义链表结构

```js
// 链表节点
class ListNode{
    constructor(value) {
        this.val = value
        this.next = null
    }
}
// 链表
class List{
    constructor(){
        this.size=0
        // 创建虚拟头节点
        this.head=new ListNode(-1)
    }
}
```

对链表进行操作时由于头节点没用前一个节点所以对其处理需要单独操作，为了让所有节点操作都是一致的（可以用相同的逻辑处理链表的节点），设置一个虚拟头节点在头节点前面



## 判断链表有无重复节点的情形

这类情形包括[链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/)、[环形链表](https://leetcode.cn/problems/linked-list-cycle-ii/)等诸多需要判断当前节点是否是之前已经遍历过的节点的场景

通过*es6*新的数据类型*map，set*来建立哈希表是最快速的方法



# 判断数组深度

就是求k叉树深度

```js
function getDep(arr){
    if(!(arr instanceof Array)) return 0
    if(arr.length==0) return 1
    let maxDep=0
    for(const item of arr){
        const curDep=getDep(item)
        if(curDep>maxDep){
            maxDep=curDep
        }
    }
    return maxDep+1
}
```



# 字符串

## 反转字符串

将字符串使用split('')变为数组后，使用数组的reverse()返回，之后使用join("")将数组变为字符串，即可实现反转字符串的效果



## 异位词

判断两个词是否是异位词：将两个词变为数组，之后排序后再拼接为字符串得到key，比较两个key是否一致来判断是否是异位词

```js
let arr=Array.from(word)
let key=arr.sort.join('')
```



# 二叉树

## 二叉搜索树

二叉搜索树判断可以结合中序遍历的结果来看：二叉搜索树⟺中序遍历结果为升序



# 前缀和+哈希表

前缀和：当前元素及之前所有元素之和

对于求连续元素和为某个target值时，可以采用**当前元素前缀和**减去**上一个元素的前缀和**=target来判断

一般方法为使用for循环从前往后遍历，将当前位置的前缀和使用map（key为和，value为这个和出现次数）记录，通过哈希表中有无记录某前缀和和（key）使得当前位置前缀和---哈希中记录的某个key前缀和=target，即哈希表中记录的前缀和满足=当前位置前缀和---target的值



# 动态规划

动态规划意味着后面的结果取决于前面的结果（前面2-3个状态）：dp[i]=dp[i-1]+dp[i-2]

写动态规划公式时从后面出发来写递推公式，而在dp数组初始化遍历得到最终结果却是从前往后

> 动态规划步骤：
>
> 建立dp数组，确定元素及下标含义
>
> 确定递推公式
>
> dp数组初始化
>
> 确定遍历顺序



# 数据结构

## 哈希表map、set

查询一个元素是否出现过，或者一个元素是否在集合里的时候用哈希表

可以使用map，set来建立哈希表

map的实例方法

map是键key不能相同，所以一般使用key来存储值，value为数组下标索引来做哈希表

```js
// 设置键值对
map.set('key','value')
// 取值
map.get('key')
// 判断是否存在某个键
map.has('key')
// 删除某个键
map.delete('key')
// 获得所有键的迭代对象 
map.keys()
// 获得所有值的迭代对象
map.values()
// 获得所有键值对的迭代对象
map.entries()
通过map.size获取map大小

对迭代对象的遍历
for(let key of map.keys()){
    每次遍历都拿到key
}
for(let [key,vlaue] of map.entries()){
    每次遍历都拿到key,value
}
for(let [key,value] of map){
    每次遍历都拿到key,value
}
对迭代对象展开得到所有key
...map.keys()
```

判断两个map的内容是否相同

```js
判断两个map的size与每对键值对内容
function compare(map1,map2){
    if(map1.size!=map2.size) return false
    for(let [key,value] of map1){
        if(!map2.has(key) || map2.get(key)!=value) return false
    }
    return true
}
```

set的实例方法

set可以看成key与value相同的map

```js
// 添加值
set.add(val)
// 判断是否有某个值
set.has(val)
// 删除某个值
set.delete(val)
// 获得所有值的迭代对象 
set.values()/set.keys()
// 获得所有键值对的迭代对象
set.entries()
通过set.size获取set大小
```

## 数组API

